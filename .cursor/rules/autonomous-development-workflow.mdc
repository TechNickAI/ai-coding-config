---
description: When completing tasks autonomously without human supervision
alwaysApply: false
---

# Autonomous Development Workflow

This guide is for AI agents completing tasks without human supervision. You're being trusted to deliver production-quality code that follows the project's standards.

## Core Principles

**Quality over speed.** Take the time to understand the project's standards, use its tooling correctly, and validate your work thoroughly before submitting.

**Use the project's tooling, don't fight it.** Every project has validation tools set up (linters, formatters, tests, pre-commit hooks). Use them to ensure your code meets standards instead of trying to manually comply.

**Self-review rigorously.** You don't have a human checking your work until after submission. Review your own code as critically as you'd review someone else's.

## Understanding Project Standards

Before writing code, understand how this project works:

**Read the cursor rules** - Look in `.cursor/rules/` directory (or `.cursorrules` file for older projects). These define the project's coding standards, patterns, and preferences.

**Check the tooling** - Look for:
- `.pre-commit-config.yaml` - Pre-commit hooks configuration
- `.github/workflows/` - CI/CD validation (commonly `build.yml`)
- `pyproject.toml` or `ruff.toml` - Linting/formatting configuration
- Test configuration (pytest.ini, setup.cfg, etc.)

**Understand the validation pipeline** - Read the GitHub Actions workflow to know what checks will run in CI. Your code must pass all of these locally before submitting.

## Using Project Tooling

### Pre-commit Hooks

If `.pre-commit-config.yaml` exists, use it:

```bash
pre-commit run --all-files
```

Pre-commit often handles linting, formatting, and other checks automatically. Let it do the work.

### Linting and Formatting

For Python projects with Ruff:

```bash
ruff check --fix .    # Auto-fix linting issues
ruff format .         # Auto-format code
```

Use the tools to fix issues automatically instead of manually editing. Tools are faster and more consistent than manual fixes.

### Testing

Run the test suite and ensure all tests pass:

```bash
pytest
# or whatever test command the project uses
```

If you added new functionality, write tests for it. Follow the project's test patterns.

### Replicate CI/CD Locally

**Read `.github/workflows/build.yml` (or ci.yml, test.yml)** and run the same validation steps locally. Common steps:

- Install dependencies
- Run pre-commit (if configured)
- Run linter
- Run formatter check
- Run tests
- Run type checker
- Build/compile

Execute these in the same order as CI to catch issues before pushing.

## Code Quality

**Follow the cursor rules.** The project has defined its standards in cursor rules. Read them and apply them.

**Write thorough file-level comments.** Explain what the file does, why it exists, and how it fits into the larger system. This helps both humans and AI understand context.

**Keep functions focused.** Each function should do one thing well. Extract complex logic into well-named helper functions.

**Use type hints.** They serve as inline documentation and enable better tooling.

**Write useful docstrings.** Explain what the function does and why, not redundant parameter documentation that type hints already provide.

**Handle errors appropriately.** Follow the project's error handling patterns. If cursor rules specify exception handling approaches, follow them.

## Self-Review Process

Before creating a PR, critically review your own code:

**Review against cursor rules** - Read through ALL cursor rules in the project and verify your code follows each applicable guideline.

**Read your own diff** - Run `git diff` and read every line. Look for:
- Debugging code or print statements left behind
- Commented out code
- TODOs that should be addressed now
- Inconsistent formatting
- Missing error handling
- Code that violates project patterns

**Ask yourself**:
- Does this solve the stated problem completely?
- Did I handle edge cases?
- Did I add tests for new functionality?
- Would I approve this in a code review?
- Is this code I'd be proud to have my name on?

## Submitting Work

### Commit Message

Follow the project's commit message standards (often defined in cursor rules like `git-commit-message.mdc`). Write a clear message explaining why the change was made.

### Create Pull Request

Use `gh` CLI to create a PR:

```bash
gh pr create --title "Brief description" --body "

## What Changed

Explain what you implemented and why.

## Validation

- All tests pass locally
- Linting and formatting pass
- Pre-commit hooks pass (if configured)
- Manually tested functionality
- Code follows all cursor rules

## Notes

Any important context, decisions made, or areas that need extra attention.
"
```

## When to Proceed vs When to Ask

### Proceed autonomously when:

- Using project's existing tooling (ruff, pytest, pre-commit)
- Following documented patterns in the codebase
- Making changes within the task scope
- Installing dependencies already in requirements files

### Ask for guidance when:

- Adding new dependencies not in requirements
- Making architectural changes beyond task scope
- Modifying CI/CD configuration
- Changing database schemas
- Uncertain about security implications
- Introducing patterns not already in the codebase

## Error Recovery

When validation fails:

**Understand the error first.** Read the full error message and trace. Don't just try random fixes.

**Fix the root cause.** If tests fail, fix the code. If linting fails, let ruff fix it. If the build fails, understand why and address it properly.

**Don't suppress errors.** If something fails, it's usually a signal that your code needs improvement, not that the tooling is wrong.

## Success Criteria

Your autonomous work is successful when:

- Human reviewer can understand what you did and why from the PR
- All automated checks pass (pre-commit, tests, linting, CI)
- Code quality matches the project's existing standards
- The solution actually solves the stated problem
- No surprises or unexplained decisions
- You'd be comfortable with this code running in production

## Remember

You're being trusted to work independently. Honor that trust by:
- Following the project's established patterns and standards
- Using the project's tooling correctly and completely
- Being thorough in testing and validation
- Reviewing your own work critically
- Submitting clean, professional work

The goal is to deliver code that requires minimal human review because you've already done that review yourself.
