---
description: when writing python code or running python commands
alwaysApply: false
---

# Python Guidelines

## Imports - CRITICAL RULE

**⚠️ ALL IMPORTS AT THE TOP OF THE FILE ⚠️**

Place all import statements at the top of the file. Never put imports inside functions or methods.

### Standard Pattern (Always Do This)

```python
from decimal import Decimal
from pathlib import Path
import json
import requests
from django.db import models

def process_payment(amount: str):
    decimal_amount = Decimal(amount)
    return decimal_amount * 2

def load_config():
    config_path = Path("config.json")
    return json.loads(config_path.read_text())

def fetch_data(url: str):
    response = requests.get(url)
    return response.json()

def save_user(email: str):
    user = models.User.objects.create(email=email)
    return user
```

Every file follows this pattern: imports at top, then functions. No imports inside functions.

### Other Import Rules

- Group imports: stdlib → third-party → local application imports
- Don't abbreviate packages (write "pandas" not "pd", "numpy" not "np")
- One import per line for clarity

### Exception: Circular Import Issues

Only import inside a function if you have a circular import problem (rare):

```python
# models.py
def create_team_for_user(user):
    from apps.teams.models import Team  # Avoids circular import
    return Team.objects.create(owner=user)
```

## Modern Python

We use python 3.13+ and follow modern best practices:

- Use `Path` lib for files instead of `open`
- Use `var!s` instead of `str(var)`
- Prefer walrus operator (:=) to reduce repetition in code
- Use modern union syntax `X | Y` instead of `Union[X, Y]`
- Use underscore separators in large numbers: `Decimal(1_000_000)` not `Decimal("1000000")`

## Attribute and Method Naming

Make everything public by default. We're all consenting adults here.

```python
class OrderProcessor:
    def __init__(self):
        self.cache = {}
        self.retry_count = 3
        self.api_client = APIClient()

    def process_order(self, order_id: str):
        return self.validate_and_process(order_id)

    def validate_and_process(self, order_id: str):
        if order_id in self.cache:
            return self.cache[order_id]
        result = self.api_client.fetch(order_id)
        self.cache[order_id] = result
        return result

class PaymentHandler:
    def __init__(self):
        self.processor = StripeProcessor()
        self.webhook_secret = get_secret()

    def handle_payment(self, amount: Decimal):
        return self.processor.charge(amount)

    def verify_webhook(self, signature: str):
        return hmac.compare_digest(signature, self.webhook_secret)
```

Only use underscore prefix (`_internal`) when accessing something would genuinely break functionality. This should be extremely rare - maybe once per thousand attributes.

```python
class DatabasePool:
    def __init__(self):
        self.max_connections = 10
        self._lock = threading.Lock()  # Direct access would break thread safety

    def get_connection(self):
        with self._lock:  # Must use lock, not access directly
            return self.create_connection()
```

If you're tempted to add an underscore, ask: "Would accessing this directly actually break something, or am I just signaling intent?" If it's just intent, skip the underscore.

## Async vs Sync

**Default to synchronous code.** We use Celery for background jobs with multiple workers, so we don't need async to free up CPU. Synchronous code is simpler, easier to debug, and easier to maintain.

**When given a choice between sync and async, always choose sync.**

```python
# ✅ GOOD: Sync by default
def fetch_data(url: str) -> dict:
    response = requests.get(url)
    return response.json()

# ❌ AVOID: Async unless necessary
async def fetch_data(url: str) -> dict:
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        return response.json()
```

**If async is the ONLY option** (library only provides async API):

1. Consider using `asyncio.run()` to call it from sync code:

```python
import asyncio

def sync_wrapper(param: str) -> dict:
    """Synchronous wrapper for async-only library"""
    return asyncio.run(async_library_call(param))
```

2. Ask for confirmation before introducing async patterns
3. Document why async is necessary

**Exceptions where async is appropriate:**

- WebSocket connections that need concurrent handling
- Libraries that are async-only (and can't be wrapped easily)
- Specific performance-critical paths where async provides clear, measured benefits

## Exception Handling - CRITICAL

**⚠️ DEFAULT: LET EXCEPTIONS BUBBLE UP ⚠️**

We use Honeybadger for centralized error tracking. Exceptions bubble up automatically. **Write code that crashes on errors - no try/except blocks in 99% of functions.**

### How to Write Functions (The Default Pattern)

Write straightforward code with no error handling. Let operations fail naturally:

```python
def process_payment(order_id: str):
    order = Order.objects.get(id=order_id)
    result = stripe.charge(order.amount)
    order.status = "paid"
    order.save()
    return result

def load_config():
    config_path = Path("config.json")
    return json.loads(config_path.read_text())

def update_user_email(user_id: str, new_email: str):
    user = User.objects.get(id=user_id)
    user.email = new_email
    user.save()
    return user

def fetch_exchange_rate(currency: str):
    response = requests.get(f"https://api.example.com/rates/{currency}")
    return response.json()

def calculate_total(order: Order):
    subtotal = sum(item.price * item.quantity for item in order.items.all())
    tax = subtotal * order.tax_rate
    return subtotal + tax
```

Notice: No try/except anywhere. Operations that can fail (database queries, API calls, file operations) are written directly. Honeybadger catches and reports any exceptions.

### The Only 2 Times You Use try/except

**SCENARIO 1: You have actual alternative logic**

Only use try/except when you have meaningful alternative behavior:

```python
def get_or_create_user(email: str):
    try:
        return User.objects.get(email=email)
    except User.DoesNotExist:
        return User.objects.create(email=email)

def api_endpoint(request):
    try:
        result = process_transaction(request.data)
    except InvalidTransactionError as e:
        return JsonResponse({"error": "validation_failed"}, status=400)
```

**SCENARIO 2: Bulk processing loops**

When processing multiple items and one failure shouldn't stop others:

```python
def sync_all_orders():
    for order_id in order_ids:
        try:
            sync_order(order_id)
        except SyncError as e:
            logger.error(f"Failed to sync {order_id}: {e}")
            continue
```

**SCENARIO 3: Adding Honeybadger context**

Catch only to add context, then immediately re-raise:

```python
try:
    result = external_api.call()
except APIException as e:
    honeybadger.notify(e, error_class="ExternalAPIError", context={"operation": "payment"})
    raise
```

### The Decision Rule

Ask: **"Do I have specific alternative behavior for this error?"**

- NO → Write the function with zero try/except blocks
- YES → Use try/except with specific exception type and alternative logic

### What NOT To Do

Avoid these patterns (described, not shown):

- Wrapping functions in generic `except Exception`
- Catching exceptions just to log and return None
- Using try/except "just in case" without specific handling
- Catching `DoesNotExist` exceptions without alternative logic

## Defensive Programming - FORBIDDEN

**NEVER use hasattr() or getattr() unless there's a REALLY good reason**

```python
# ❌ BAD: Checking if methods exist
if hasattr(self, "create_trade"):
    self.create_trade()

# ✅ GOOD: Just call it - it exists!
self.create_trade()
```

**NEVER use dict.get() with default values for critical data that SHOULD exist**

```python
# ❌ BAD: Silent failures that hide bugs
filled_size = Decimal(str(order_data.get("filledSz", "0")))  # Hides missing data!

# ✅ GOOD: Fail fast on missing data
filled_size = Decimal(str(order_data["filledSz"]))  # Crashes if data is malformed
```

Only use `.get()` with defaults for:

- Optional configuration
- Optional metadata
- Legitimate optional fields

## Financial Data

- Use Decimal for financial calculations - never use float for money/prices

## DRY Principle

Follow DRY (Don't Repeat Yourself) principles. Extract repeated logic into shared methods.
