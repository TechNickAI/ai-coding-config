---
description: Autonomous task workflow using git worktrees
alwaysApply: false
---

# Git Worktree Task Workflow

When completing tasks autonomously, we work in git worktrees. This isolates our work,
keeps the main working directory clean, and allows context switching without losing
state. The goal: deliver a pull request that passes all checks and merges without
back-and-forth.

## Why Git Worktrees

Worktrees let you work on multiple branches simultaneously without stashing or losing
context. Your main directory stays on `main` for quick reference. Your task directory is
isolated. You can switch between them instantly. When done, the worktree disappears
cleanly.

## The Complete Cycle

**Setup your workspace.** Create a git worktree for the task. Choose a branch name that
describes what you're building. The worktree should be in the `.gitworktrees/` directory
to keep things organized.

```bash
# Create worktree in .gitworktrees directory
mkdir -p .gitworktrees
git worktree add -b feature/task-name .gitworktrees/task-name main
cd .gitworktrees/task-name
```

**Initialize the environment.** Run the setup command to prepare the worktree:

```bash
/setup-environment
```

This prompts your AI assistant to detect the project type and intelligently set up
dependencies, code generation, and environment files. The goal is to make the worktree a
fully functional development environment where all tests pass.

**If `/setup-environment` doesn't exist** in your project, set up manually:

For Node.js/TypeScript projects:

```bash
pnpm install
[ -f prisma/schema.prisma ] && pnpm db:generate
```

For Python projects:

```bash
pip install -r requirements.txt  # or poetry install
python manage.py migrate  # Django
# or: alembic upgrade head  # SQLAlchemy
```

For Ruby projects:

```bash
bundle install
bundle exec rake db:migrate  # Rails
```

**Copy environment files** if setup command didn't:

```bash
# Copy all environment files from parent directory
cp ../../.env .env 2>/dev/null || cp .env.example .env
cp ../../.env.local .env.local 2>/dev/null || true
cp ../../.env.*.local . 2>/dev/null || true
```

**Note on .env files:** Copy .env from the parent directory. It contains database URLs
and API keys needed for integration tests. After proper setup, ALL tests (unit +
integration) should pass in your worktree.

**Read the standards.** Before writing code, read all cursor rules in `.cursor/rules/`.
These define how this project works. Every applicable rule must be followed. If
`CLAUDE.md` or `AGENTS.md` exist at the project root, read those too.

**Implement the solution.** Write code that solves the problem. Follow all cursor rules.
Make commits along the way as logical units of work are completed. Each commit should
follow the git commit message guidelines in .cursor/rules/git-commit-message.mdc (or
.md).

**Validate locally before pushing.** Run the project's pre-push validation. This catches
issues before CI does, saving time and CI minutes. Look for these commands:

- Node.js: `pnpm pre-push`, `npm run pre-push`, or check `package.json` scripts
- Python: `pre-commit run --all-files`, `pytest`, `ruff check`, `mypy`
- Ruby: `bundle exec rake test`, `bundle exec rubocop`
- Go: `go test ./...`, `golangci-lint run`
- Rust: `cargo test`, `cargo clippy`

You can also check `.github/workflows/` to see what CI runs - run those steps locally.

**All tests should pass in a properly configured worktree.** After running
`/setup-environment`, your worktree should be a fully functioning development
environment where:

- ✅ Unit tests pass (use mocks, no external dependencies)
- ✅ Integration tests pass (have real .env with database access)
- ✅ Type checking passes (code generation completed)
- ✅ Linting passes (dependencies installed)

If tests fail, it's either:

1. **Setup incomplete** - Did you run `/setup-environment`? Check that .env was copied
   and dependencies installed.
2. **Your code has bugs** - Fix them before pushing. The local tooling is telling you
   what's wrong.

Never push hoping CI will tell you what's broken - the local tooling already told you.
Worktrees should be complete, working environments. No excuses.

**Self-review your changes.** Invoke the code reviewer agent (Rivera in
.claude/agents/rivera.md) to review your changes before pushing. The reviewer catches
bugs, security issues, design problems, and maintainability concerns that you might have
missed. Address critical issues. Consider warnings seriously. Evaluate suggestions for
merit.

The reviewer's feedback is educational - learn from it. If you disagree with feedback,
explain your reasoning. But if the feedback points out an actual problem, fix it before
pushing.

**Push and create the PR.** Once local validation passes and code review is addressed,
push your commits. Create a pull request with a clear description of what changed and
why. The PR description should help reviewers understand the context and the decisions
you made.

**Wait for CI to complete.** - Let all CI jobs run to completion (usually about 3
minutes). The project has multiple validation jobs (code quality, tests, build). All
must pass. Green checks are required before merge.

This is a good time to review and update documentation while you are waiting for the PR
to build. If you don't have anything to do, you can run a bash sleep 180 to sleep for a
bit. Take a nap.

Run gh to check on the build. If CI fails, read the logs carefully. Understand what
broke and why. Fix the issue and push again. Don't guess - the CI logs contain the
information you need.

**Wait for AI bot reviews.** There are AI code review bots that will be operating on the
pull request. AI bot reviews to complete. These bots analyze code for additional issues
that automated checks might miss.

**Address feedback intelligently.** When the code review bots provide feedback, evaluate
it critically. You have full project context - the bots don't. Some feedback is valuable
and should be addressed. Some feedback is incorrect or not applicable and should be
marked WONTFIX with clear reasoning.

Be smarter than the bots. If feedback conflicts with project standards, follow project
standards. If feedback suggests changes that would break functionality, explain why it's
WONTFIX. If feedback identifies a real issue, fix it. Do not let them talk you into
adding unnecessary complexity. Be discerning. Some feedback is eyeroll worthy. If it's
helpful, you can use gh to mark the feedback as positive / negative with a github
reaction.

**Merge when all checks pass.** Once CI is green, bot reviews are addressed, and all
checks pass, the PR is ready. Either merge it yourself or wait for the human reviewer to
merge it.

**Clean up the worktree.** After the PR merges, remove the worktree to keep things tidy:

```bash
# Return to main directory
cd ../.. # or cd /path/to/main/repo

# Remove the worktree
git worktree remove .gitworktrees/task-name

# Or use the cleanup command if available
/clean-up-worktree  # if project has this slash command
```

The worktree directory and its files are deleted, but your work lives on in main via the
merged PR.

## Common Pitfalls

**Skipping environment setup.** After creating the worktree, always run
`/setup-environment` or manually install dependencies. Type errors and test failures
often stem from missing code generation (Prisma, etc.) or dependencies.

**Skipping local validation.** Don't push without running pre-push checks. You'll just
waste time waiting for CI to tell you what your local tooling would have caught in
seconds.

**Blindly following bot feedback.** Bots provide suggestions, not mandates. Evaluate
each piece of feedback. You have context they don't. Make informed decisions about what
to fix and what to WONTFIX.

**Not verifying full test suite.** After setup, ALL tests should pass - both unit and
integration tests. If tests fail, fix your setup or your code. Don't push with failing
tests.

## Success Criteria

A successful autonomous task means: the original request is completed, all automated
checks pass, code follows all cursor rules, tests are green, code review was addressed,
bot feedback was evaluated intelligently, and the PR merges without human intervention
requesting changes.

The tools are your friends. Use them. They catch issues early when they're easy to fix.
They validate your work before it becomes someone else's problem. They help you deliver
quality code that people trust.
